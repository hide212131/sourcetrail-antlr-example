# Example of Sourcetrail Custom old.Indexer using Antlr4

## 目的
1. 色々な言語でSourceTrailと連携させたい。
1. 色々な言語でシンボルソルバーを簡単に実装したい。

## 実装解析

antlr+srctrailでやってることの分析

* symtabによるスコープツリーの構築を楽にさせること
* スコープツリーの構築を生かして、NameElement, NameHierarchyの代わりにして sourceTrailの連携を楽にすること

* old.common.DefPhase
  * FunctionSymbolを作成
  * 一意な名前をつける
    * 言語によって異なる
      * 型がありなし。オーバーロードありなし。 
    * 一意な名前＝シンボル名＋スコープ階層
    * シンボル名＝型(引数、戻り値)と名前
    * スコープ階層の作り方
      * 以下をデフォルト実装
        * たいていは、スタックに積む
        * シンボル＋スコープはわかりやすい。（SymbolWithScope）
      * 以下はあとで考えよう。拡張可能にしよう。
        * シンボルなしスコープのみはありえる？わからん。
        * ジェネリクス＋ラムダは辛いらしい
          * https://github.com/javaparser/javaparser/wiki/About-the-Symbol-Solver 
            
  * srctrailに登録
    * シンボルを登録
    * IDを取得（登録時に）
    * シンボルとIDの関連付け
    * シンボルの型の登録
    * シンボルの位置（開始、終了）の登録
    * シンボルが持つスコープの位置（開始、終了）の登録
  * エラー処理
* old.RefPhase
  * 参照名をとりだす
  * スコープ階層から、参照先→シンボルを求める。
    * symtabのBaseScope.resolveで.
    * スコープ階層を作っておく必要。
  * 参照元シンボルをもとめる（sourcetrail用）
  * 登録する。
  * 参照の範囲を登録する。
  * エラー処理   
   

## 実装ポイント
* antlrのwakerタイプ
  * antlrは、構文に入った出た。
  * 今回のAPIは、シンボルに入った。
* 名前の階層と、スコープ階層はべつかな、いやどうかな。
  * スコープ階層は、名前解決の材料の一つ
  * 名前階層は、一意にさせるための階層構造。
    * DefPhaseではこれを重視
    * でも、DefPhaseで、スコープツリーというよりDOMツリー作ってしまうのが楽。
    * DOMツリーは、細かく作るときりがない。ソース参照のみに最小化させる。
      * 結局、DOMツリー＝DOMツリー＝スコープツリーになるのでは。
    * class A extend B のA→Bの参照ってDefPhaseで作れる？
      
* レゾルバ 
  * 言語依存
    * どれを定義とするか
      * 部分実装で関数だけ、など 
    * 一意に求まるシンボル名の求め方
      * 型のありなし、オーバライドありなし
    * シンボルの参照のたどり方
      * 名前の付け方と似ている。同じ？     
  * 結局ソルバーの役割は
    * シンボルの辞書を作成して
      * 一意であることが必須。名前階層を
    * あとから解決する
      * 言語依存。たどり方。一致の条件。
        * たどり方。スコープ階層。クラス階層。import
        * 一致条件。型。名前。引数。

* 役割分担
  * DefListener
    * 定義(Def。宣言は実装がないので今回対象外）に入ったら呼ばれる    
    *      
  
  * レゾルバ
    * DefPhaseで作られる
  * sourcetrailは実装の一つとして分離 
* enter/exitのexit側は意識しなくて良い実装


  
   
